
前一阵多步RAG的风吹入了工业界，kimi推出了探索版本，各应用都推出了深度搜索，You.COM更是早就有了Genius的多步模式。其实都是类似multi\-hop RAG的实现。之前学术界在讨论multi\-hop RAG的时候总是给一些基于历史知识类的问题，什么某年诺贝尔奖的获奖人在哪读的大学呀，给人一种错觉就是这类问题现实世界里真的有人这么提问么？其实还真有！


这里举几个单步RAG效果可能不好的case，在碰到的很多场景里，多步RAG其实主要针对模糊指代的问题，包括


1. **偏动态信息的主体指代：例如事件，产品，政策，现象**


* 华为最新型号的手机市场怎么看：需要先获取华为最新的手机型号
* 最新出台的房地产政策专家解读：需要先获取最新的房地产政策
* 请根据当前的市场成交情况，分析当前市场情绪：需要获取当前市场成交数据


2. **偏静态知识的主体指代：例如分类，话题，主题，相关主体**


* 近三年全国各大电影节的获奖名单：需要先获取有哪些电影节，再逐个获取每个电影节的获奖名单
* 光伏上下游产业链近期有哪些利好政策：需要先获取光伏上下游产业链节点


3. **抽象指代：需要先验知识，专家经验，对前置问题的回答**


* 请依据美林时钟，判断从2013年到2023年间都经历哪些经济周期阶段：需要先获获取美林时钟的定义
* 探讨我国粮食价格的形成机制，从市场供求关系、政策调控等多个因素分析价格变动的原因：需要先搜索粮食价格形成机制


4. **多条件指代：因为条件过于复杂，需要多步缩小筛选范围**


* 哪些国家在内部制造业不景气的时候，通过设立贸易壁垒来解决失业率过高的问题
* 哪些中央银行，曾经因为长时间通货膨胀居高不下，在经济不景气的时候还不得不提高提率水平


5. **时间指代**


* 贵州茅台最新季报的资产负债情况：需要先获取当前时间，定位季报
* 近一周异动板块有哪些：需要获取当前时间，并定位时间窗口


前面说单步RAG**可能**解决不好，因为以上的场景当你幸运的召回了正确的数据时，包括但不限于query改写拆解引入相关信息，检索部分解决了时效性问题，模型自身压缩知识的辅助等等，其实是有可能解决的，当然需要碰运气哈哈哈\~\~


例如华为手机刚发布大热，那你不需要获取华为最新的手机号，直接使用搜索引擎搜索“华为最新型号的手机市场怎么看”,这时搜索引擎已经帮你处理了热点的时效性问题，大概率你就能获得正确的答案。


再比如"光伏上下游产业链近期有哪些利好政策"，可能把query拆解为光伏上游产业链利好政策\+光伏中游产业链利好政策\+光伏下游产业链利好政策，你不需要知道上中下游具体是啥，也是能检索到部分有效信息的。


但是！我们需要的是可以稳定解决复杂，多条件，模糊指代问题的方案！


所以下面我们会给出多步RAG的几个核心步骤和对比，再讨论几篇论文大致的实现方案，论文细节大家感兴趣可以自己去看。更多RAG query改写，召回，粗排，精排的多个步骤我们在前面的章节已经说过，这里就不提了\~


## 方案对比


懒得看具体方案的小伙伴直接看对比吧，这里总结对比下多步RAG的几个核心模块，和几种实现方案




| 模块 | 方案1 | 方案2 | 方案3 | 对比 |
| --- | --- | --- | --- | --- |
| 规划模块/COT | 每次只基于上一步的检索规划下一步的局部规划方案 | 全局预规划 | 先全局预规划再进行修订 | 局部规划方案容易歪楼，有时会缺少整体视角；全局规划是否需要修订其实部分取决于拆分步骤的方式，如果拆分过程不和query耦合其实多数场景不用修订也是可以的 |
| 子Query生成 | 和规划等同（规划本身就是子Q） | 和规划一起全局生成 | 依赖前面的的检索结果生成（全部or上一步） | 方案2和3结合的方式更常见，依赖检索结果的Query提供更加specific的检索视角，而只依赖主Q拆分的子Q提供更加general的检索视角 |
| 推理 | 每一步独立推理拼接最后润色 | 获得所有检索结果后一体生成 | 每一步基于上一步的推理和新获得的检索内容向后续写 | 连贯性最好幻觉较低，但对模型长文本有更高要求的肯定是一体化生成方案类似Kimi；You.COM的生成结果更类似于多步推理再拼接润色；而对于一些超长文本生成续写的方案使用更多 |


在尝试过You.COM的Genius模式，Kimi的探索模式，智谱的深度搜索后，发现除了以上的核心模块，多步RAG还有以下几个可以进一步提升效果的方向


1. Reflection: 复杂问题往往很难一步到位，通过对推理结果进行反思，发现遗漏的方向，然后新增一步检索推理进行补充，或者对原始推理修订


![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233419-265382214.png)


2. 针对多跳问题设计更适配的Query生成方案：复杂query往往涉及多条件，或者多主体，因此在Query拆解上需要有更多的视角。几种Query生成视角包括


* 相似改写：最常见的单步RAG主要使用
* 角度拆解：问题独立的多个视角（多步RAG的问题拆解是串行的这里是并行的），单步RAG主要使用，例如


![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233335-1386306073.png)


* 抽象、系统思维：类似step\-back prompt，通过对问题抽象，获取领域概念或先验知识，多步RAG的第一步query拆解常用，例如
![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233321-1865513878.png)
* 简化假设：通过放宽问题假设来补充信息召回，多步RAG中多条件的复杂问题常用，例如


![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233469-7997186.png)


* 实体遍历: 通过对第一步检索得到的实体进行遍历生成第二步检索的query，通过明确主体获得更丰富的主体信息，多步RAG的第二步常见，例如
![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233355-496504271.png)
* 历史视角：分析影响类问题，事件解读类问题，多引入历史视角来补充观点


## 几种实现


### 局部 \+ 生成：IRCOT



> * Interleaving Retrieval with Chain\-of\-Thought Reasoning for Knowledge\-Intensive Multi\-Step Questions
> * [https://github.com/StonyBrookNLP/ircot](https://github.com)


![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233584-1302949864.png)


这里IRCOT的实现最为简单，我们那这篇论文作为基准论文。IRCOT的整个流程是


1. Retrieve：用户Query进来直接去检索
2. COT：检索内容作为上文，使用以下prompt进行COT推理，只保留COT推理的第一个段落
3. Retrieve：使用上一步推理的句子直接作为Query取进行搜索
4. COT：使用当前检索到的全部上文，之前COT推理完成的段落，再继续进行推理并保留第一个句子。
5. 不断重复Retrieve，COT直到模型给出"The answer is"，或者超过最大迭代步骤


IRCOT的几个特点包括


* 没有全局的规划：每一步都是先检索再向前推理一步
* 没有Query生成：Query直接来自上一步推理的COT，没有额外生成
* 直接推理生成：COT是直接基于检索，和前面的推理结果进行继续生成
* 每一步都独立推理: 不会修改前面的生成结果


以下是基于检索内容生成COT推理的prompt格式



```
Wikipedia Title: 

...
Wikipedia Title: 

Q: 
A:  ... 

```

### 全局 \+ 生成：Search in the chain



> * Search\-in\-the\-Chain: Towards Accurate, Credible and Traceable Large Language Models for Knowledge\-intensive Tasks
> * [https://github.com/xsc1234/Search\-in\-the\-Chain](https://github.com)


![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233426-1022838361.png)


对比前面的IRCOT，Search in the chain会预先生成全局规划，并且规划的步骤中增加了子问题的拆解生成。每一步检索后，都根据检索重新生成新的全局规划。以下是Search in the Chain的实现步骤


1. SearchChain：针对问题生成全局的SearchChain，包括问题拆解的多个子query，并且每个子问题会让模型判断能否直接回答


* 能：直接给出\[Answer]
* 不能: 给出\[Unsolved Query]


2. Retrieve：把以上的全局SearchChain按结构拆分成多个步骤，第一步的query先去进行检索
3. Revise or Generate：根据第一个节点的检索结果，如果当初模型判断这个节点子问题无法回答(Unsolved Query)则根据检索进行生成，如果当初模型判断可以回答但答案和检索不一致，则根据检索进行修订，两种逻辑的prompt不同，会根据searhChain选择不同的prompt拼接到模型的上文
4. Revise SearchChain: 然后新的上文，让模型重新生成新的SearchChain，再接着遍历下一个节点进行步骤2\~3，直到结束


SearchChain的几个特点包括


* 全局预规划
* Query预生成：Query就是全局规划中拆分的子问题
* 允许基于前一步的检索结果调整全局规划，但其实之所以需要调整，就是因为query和规划是一起做的，所以当中间推理答案错误的时候，下一步的query生成也会存在问题，所以需要重新生成


以下是Search in the chain构建search chain的prompt


![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233485-1088151722.png)


### 全局 \+ 修订：RAT



> * Retrieval Augmented Thoughts Elicit Context\-Aware Reasoning in Long\-Horizon Generation
> * [https://github.com/CraftJarvis/RAT](https://github.com):[milou加速器](https://xinminxuehui.org)


![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233568-693449869.png)


对比Search Chain，RAT也是生成全局规划，但是把query生成的步骤，放到了检索之后，同时把基于检索重新生成的方案，替换成了基于检索对初始回答进行修正。RAT的整体流程是


1. COT：用户query进来先让模型进行COT推理，然后把COT按\\n\\n分成多个段落（step）
2. ToQuery：针对第1个段落的推理生成检索Query
3. Retrieve：基于检索query发起检索
4. Revise: 使用检索结果，对第1个段落进行修订
5. TOQuery：针对第1个修订段落\+第2个原始段落生成检索Query
6. Retrieve：基于检索query发起检索
7. Revise: 使用检索结果，对前面的所有段落进行修订
8. 遍历各个段落重复ToQuery，Retrieve，Revise的步骤直到结束


RAT的几个特点包括


* 全局预规划
* 串行Query生成，并使用全部历史信息：每一步Query生成，都是用前面生成的全部信息。更不容易丢失核心主体信息，但同时可能会让Query过于宽泛不够具体。
* 修订而非生成：使用检索结果修改原始推理而非直接生成，能更多保留模型压缩的知识效果，但是存在内容检索不全，修订后的答案还是有错误存在的可能。
* 每一步都修订前面的所有内容：成本更高，但可能会有更好的连贯性，但也有可能因为多次修订而引入幻觉


以下分别为第一步COT回答的Prompt，query生成的prompt和基于检索内容的COT进行


![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233529-952738370.png)


![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233435-1313014639.png)


![image](https://img2024.cnblogs.com/blog/1326688/202412/1326688-20241214090233473-1197751360.png)


**想看更全的大模型论文·微调预训练数据·开源框架·AIGC应用 \>\>** [**DecryPrompt**](https://github.com)


